---
layout:     post
title:      "Teach Yourself Regular Expressions in 10 Minutes"
subtitle:   "正则表达式快速入门"
date:       2018-07-07
author:     "msg"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - regex
    - 正则
    - NLP
---

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<link rel="dns-prefetch" href="//cdn.mathjax.org" />


> 万事开头难，我选择先从最容易的开始看，这本书几乎是一本小册子，加上附录130页，看得快的话，一两个小时就可以看完。

### 第1章 正则表达式入门

  讲述何为正则表达式，以及正则表达式可以做什么。
  
   1) 正则表达式是一种工具(regular expression,简称regex),是文本处理方面功能最强大的工具之一，正则表达式语言用来构造正则表达式，正则表达式用来完成搜索和替换功能。

   2) 正则表达式语言并不是一种完备的程序设计语言，而是一种内置于其他语言或软件之内的“迷你”语言。

   3) 在不同的语言里，正则表达式的语法和功能常常有所不同。

### 第2章 匹配单个字符

  讲述如何对一个或多个字符进行简单的字符匹配。

   1) 纯文本如Ben也是一个正则表达式，但是只使用纯文本的正则表达式是一种浪费，所以一般不建议使用。

   2) 一般正则表达式都可以返回一个匹配中的结果的列表。

   3) 正则表达式区分大小写，但是绝大多数正则表达式引擎都支持不区分大小写的匹配机制。

   4) .符号可以匹配任意一个单个的字符、字母、数字甚至是.字符本身。

   5) \是一个元字符（metacharacter），永远出现在一个有着特殊含义的字符序列的开头，用来对字符进行转义。

   6) 正则表达式经常被简称为模式，其实是由一些字符组成的字符串，这些字符可以是普通文本或者是元字符。

### 第3章 匹配一组字符

  讲述字符集能够匹配特定的字符和字符区间。

   1) 在正则表达式里，可以用元字符[和]来定义一个字符集合。字符集合的匹配结果是能够与该集合里的任意成员相匹配的文本。

   2) 为了简化字符间的定义，正则表达式提供了特殊的元字符-来表达字符区间。

   3) 用元字符^来表示对一个字符集合进行取非匹配。

### 第4章 使用元字符

  讲述用更多的元字符匹配特定的字符或者字符类型。

   1) 元字符是在正则表达式里有着特殊含义的字符，由于有着特殊含义，因此元字符无法代表其本身。因此需要在元字符前边加上一个反斜杠，对其进行转义。
  
   2) 匹配特定的字符类型，表格如下：


<!-- <table>
  <tr>
    <th>元字符</th>
    <th >说明</th>
  </tr>
  <tr>
    <td> \d </td>
    <td> 任何一个数字字符（等价于[0-9]）  </td>
  </tr>
  <tr>
    <td >\D </td>
    <td> 任何一个非数字字符(等价于[^0-9]) </td>
  <tr>
    <td>\w </td>
    <td> 任何一个字母数字字符或下划线字符（等价于[a-zA-Z0-9_]） </td>
  </tr>
  <tr>
    <td>\W </td>
    <td> 任何一个非字母数字字符或下划线字符（等价于[^a-zA-Z0-9_]） </td>
  </tr>
  <tr>
    <td>\s </td>
    <td> 任何一个空白字符（等价于[\f\n\r\t\v]） </td>
  </tr>
  <tr>
    <td>\s </td>
    <td> 任何一个非空白字符（等价于[^\f\n\r\t\v]） </td>
  </tr>
</table> -->



### 第5章 重复匹配

讲述如何匹配多个连续重复出现的字符或者字符集合

 1) +匹配一个或多个字符，*匹配零个或多个字符。

 2) ?只能匹配一个字符或字符集合的零次或者一次出现。?是一个元字符,要匹配?本身,就要使用转义\?

 3) 为重复次数设置一个精确的值,把数字写在{}之间即可,如{3},还可以为重复匹配次数设置一个最小值和一个最大值,如{2,4}。{3,}表示至少匹配中3次。
 4) 由于*和+都是"贪婪型"元字符,在进行匹配的时候是多多益善而不是适可而止的,不需要"贪婪行为"的时候,就用这些元字符的"懒惰型"版本,即给"贪婪型"字符后边加上一个?即可。

### 第6章 位置匹配

讲述对特定位置的文本进行匹配,用来解决在什么地方进行字符串匹配的问题。

 1) \b用来匹配一个单词的开始或结尾(在英文等西方语言中有用,对中文无用)。如果想匹配一个完整的单词,就必须在想要匹配的文本的前后都加上\b限定符。

 2) 单词边界可以用来进行与单词有关的位置匹配,字符串边界用来进行与字符串有关的位置匹配:一个用来匹配字符串开头的^,一个用来匹配字符串结尾的$。

 3) ^是有多种用途的元字符之一,只有当它出现在一个字符集合里(被放在[和]里,并紧跟在[的后边的时候,才能发挥求非的作用),如果用在一个字符集合的外边,并位于一个模式的开头,^将匹配字符串的开头。

 4) 要启用分行匹配模式,需要用(?m)元字符。在分行匹配模式下,^不仅能匹配一个正常的字符串开头,还将匹配换行分隔符后边的开始位置;$不仅能匹配正常的字符串结尾,还能匹配换行分隔符之后的结束位置。

### 第7章 使用子表达式

讲述运用子表达式的概念对正则表达式进行分组和归类.

1) 把一个表达式划分为一系列子表达式的目的是为了把那些子表达式当做一个独立元素来使用,子表达式必须用括号()括起来.

2) 子表达式允许多重嵌套,嵌套层次在理论上没有限制,但是实际工作中还是要遵循适可而止的原则.

3) 把必须匹配的情况考虑周全并写出一个匹配结果符合预期的正则表达式很容易,但把不需要匹配的情况也考虑周全并确保它们都被排除在外往往困难得多.

4) 在面对子表达式嵌套很多的表达式的时候,应该按照先内后外的原则来进行而不是从第一个字符就开始一个字符一个字符地去处理.

5) 子表达式的常见用途: 对重复次数元字符的作用对象做出精确的设定和控制,对\|操作符的OR条件做出准确的定义等.

### 第8章 回溯引用：前后一直匹配

讲述定义回溯应用

1) 回溯引用允许正则表达式引用前面的匹配结果,回溯引用只能用来引用模式里的子表达式.

2) 一些比较新的正则表达式还支持"命名捕获",给某个子表达式起一个唯一的名字,并用名字引用子表达式(如Python),但是还没有得到广泛的支持,java好像并没有支持.

3) 回溯引用可以跨模式使用,在第一个模式里被匹配的表达式可以用在第二个模式里.

### 第9章 前后查找

讲述前后查找

1) 当不需要匹配中的结果返回,只用来确定具体的位置的时候,需要前后查找.

2) 向前查找制定了一个必须匹配但是不在结果中返回的模式,在向前查找里,被匹配到的文本不包含在最终返回的匹配结果里,被称为"不消费".

3) ?=被称为向前查找操作符,查找出现在匹配文本之前的字符,向后查找操作符是?<=.

4) 向前查找模式的长度是可变的,可以包含.和+之类的元字符,所以非常灵活,向后查找模式只能是固定长度.

5) 负向前查找要用(?!)来定义,负向后查找是(?<!)

### 第10章 嵌入条件

讲述在正则表达式的内部嵌入条件处理功能

1) 正则表达式里的几种条件:
  > ① ?匹配前一个字符或表达式,如果存在的话;
  
  > ② ?=和?<=匹配前面或后边的文本,如果存在.
  
2) 如下正则表达式

```
(\()?\d{3}(?(1)\)|-)\d{3}-\d{4}"
```

这个正则表达式提供了一个电话号码的解决方案,(\()?匹配一个可选的左括号,用括号括起来得到了一个子表达式,随后的\d{3}匹配以为数字的区号,```(?(1)\)|-)```是一个回溯引用条件,它根据条件是否得到满足而去匹配)或-;如果(1)存在,```\)```必须被匹配,否则,-必须被匹配.

### 附录:元字符

<!-- <table>
  <tr>
    <th>元字符</th><th>说明</th>
  </tr>
  <tr>
    <td> \d </td> <td> 任何一个数字字符（等价于[0-9]）  </td>
  </tr>
  <tr>
    <td >\D </td> <td> 任何一个非数字字符(等价于[^0-9]) </td>
  <tr>
    <td>\w </td> <td> 任何一个字母数字字符或下划线字符（等价于[a-zA-Z0-9_]） </td>
  </tr>
  <tr>
    <td>\W </td> <td> 任何一个非字母数字字符或下划线字符（等价于[^a-zA-Z0-9_]） </td>
  </tr>
  <tr>
    <td>\s </td> <td> 任何一个空白字符（等价于[\f\n\r\t\v]） </td>
  </tr>
  <tr>
    <td>\s </td> <td> 任何一个非空白字符（等价于[^\f\n\r\t\v]） </td>
  </tr>
  <tr><td>\f </td> <td> 换页符 </td></tr>
  <tr><td>\n </td><td>换行符 </td></tr>
  <tr><td>\t </td><td> 制表符 </td> </tr>
  <tr><td>\v </td> <td> 垂直制表符 </td></tr>
  <tr> <td>\x </td><td> 匹配十六进制数字 </td></tr>
  <tr><td>\0 </td><td> 匹配八进制数字 </td></tr>

</table> -->


#### [返回主目录](https://github.com/msg901216/get-rid-of-my-books/blob/master/README.md)
