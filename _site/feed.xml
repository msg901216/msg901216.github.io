<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>慢时光的读书笔记</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 07 Jul 2018 13:45:08 +0800</pubDate>
    <lastBuildDate>Sat, 07 Jul 2018 13:45:08 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>Teach Yourself Regular Expressions in 10 Minutes</title>
        <description>&lt;script src=&quot;//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;

&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.mathjax.org&quot; /&gt;

&lt;blockquote&gt;
  &lt;p&gt;万事开头难，我选择先从最容易的开始看，这本书几乎是一本小册子，加上附录130页，看得快的话，一两个小时就可以看完。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;第1章-正则表达式入门&quot;&gt;第1章 正则表达式入门&lt;/h3&gt;

&lt;p&gt;讲述何为正则表达式，以及正则表达式可以做什么。&lt;/p&gt;

&lt;p&gt;1) 正则表达式是一种工具(regular expression,简称regex),是文本处理方面功能最强大的工具之一，正则表达式语言用来构造正则表达式，正则表达式用来完成搜索和替换功能。&lt;/p&gt;

&lt;p&gt;2) 正则表达式语言并不是一种完备的程序设计语言，而是一种内置于其他语言或软件之内的“迷你”语言。&lt;/p&gt;

&lt;p&gt;3) 在不同的语言里，正则表达式的语法和功能常常有所不同。&lt;/p&gt;

&lt;h3 id=&quot;第2章-匹配单个字符&quot;&gt;第2章 匹配单个字符&lt;/h3&gt;

&lt;p&gt;讲述如何对一个或多个字符进行简单的字符匹配。&lt;/p&gt;

&lt;p&gt;1) 纯文本如Ben也是一个正则表达式，但是只使用纯文本的正则表达式是一种浪费，所以一般不建议使用。&lt;/p&gt;

&lt;p&gt;2) 一般正则表达式都可以返回一个匹配中的结果的列表。&lt;/p&gt;

&lt;p&gt;3) 正则表达式区分大小写，但是绝大多数正则表达式引擎都支持不区分大小写的匹配机制。&lt;/p&gt;

&lt;p&gt;4) .符号可以匹配任意一个单个的字符、字母、数字甚至是.字符本身。&lt;/p&gt;

&lt;p&gt;5) \是一个元字符（metacharacter），永远出现在一个有着特殊含义的字符序列的开头，用来对字符进行转义。&lt;/p&gt;

&lt;p&gt;6) 正则表达式经常被简称为模式，其实是由一些字符组成的字符串，这些字符可以是普通文本或者是元字符。&lt;/p&gt;

&lt;h3 id=&quot;第3章-匹配一组字符&quot;&gt;第3章 匹配一组字符&lt;/h3&gt;

&lt;p&gt;讲述字符集能够匹配特定的字符和字符区间。&lt;/p&gt;

&lt;p&gt;1) 在正则表达式里，可以用元字符[和]来定义一个字符集合。字符集合的匹配结果是能够与该集合里的任意成员相匹配的文本。&lt;/p&gt;

&lt;p&gt;2) 为了简化字符间的定义，正则表达式提供了特殊的元字符-来表达字符区间。&lt;/p&gt;

&lt;p&gt;3) 用元字符^来表示对一个字符集合进行取非匹配。&lt;/p&gt;

&lt;h3 id=&quot;第4章-使用元字符&quot;&gt;第4章 使用元字符&lt;/h3&gt;

&lt;p&gt;讲述用更多的元字符匹配特定的字符或者字符类型。&lt;/p&gt;

&lt;p&gt;1) 元字符是在正则表达式里有着特殊含义的字符，由于有着特殊含义，因此元字符无法代表其本身。因此需要在元字符前边加上一个反斜杠，对其进行转义。&lt;/p&gt;

&lt;p&gt;2) 匹配特定的字符类型，表格如下：&lt;/p&gt;

&lt;!-- &lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;元字符&lt;/th&gt;
    &lt;th &gt;说明&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt; \d &lt;/td&gt;
    &lt;td&gt; 任何一个数字字符（等价于[0-9]）  &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td &gt;\D &lt;/td&gt;
    &lt;td&gt; 任何一个非数字字符(等价于[^0-9]) &lt;/td&gt;
  &lt;tr&gt;
    &lt;td&gt;\w &lt;/td&gt;
    &lt;td&gt; 任何一个字母数字字符或下划线字符（等价于[a-zA-Z0-9_]） &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;\W &lt;/td&gt;
    &lt;td&gt; 任何一个非字母数字字符或下划线字符（等价于[^a-zA-Z0-9_]） &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;\s &lt;/td&gt;
    &lt;td&gt; 任何一个空白字符（等价于[\f\n\r\t\v]） &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;\s &lt;/td&gt;
    &lt;td&gt; 任何一个非空白字符（等价于[^\f\n\r\t\v]） &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt; --&gt;

&lt;h3 id=&quot;第5章-重复匹配&quot;&gt;第5章 重复匹配&lt;/h3&gt;

&lt;p&gt;讲述如何匹配多个连续重复出现的字符或者字符集合&lt;/p&gt;

&lt;p&gt;1) +匹配一个或多个字符，*匹配零个或多个字符。&lt;/p&gt;

&lt;p&gt;2) ?只能匹配一个字符或字符集合的零次或者一次出现。?是一个元字符,要匹配?本身,就要使用转义\?&lt;/p&gt;

&lt;p&gt;3) 为重复次数设置一个精确的值,把数字写在{}之间即可,如{3},还可以为重复匹配次数设置一个最小值和一个最大值,如{2,4}。{3,}表示至少匹配中3次。
 4) 由于*和+都是”贪婪型”元字符,在进行匹配的时候是多多益善而不是适可而止的,不需要”贪婪行为”的时候,就用这些元字符的”懒惰型”版本,即给”贪婪型”字符后边加上一个?即可。&lt;/p&gt;

&lt;h3 id=&quot;第6章-位置匹配&quot;&gt;第6章 位置匹配&lt;/h3&gt;

&lt;p&gt;讲述对特定位置的文本进行匹配,用来解决在什么地方进行字符串匹配的问题。&lt;/p&gt;

&lt;p&gt;1) \b用来匹配一个单词的开始或结尾(在英文等西方语言中有用,对中文无用)。如果想匹配一个完整的单词,就必须在想要匹配的文本的前后都加上\b限定符。&lt;/p&gt;

&lt;p&gt;2) 单词边界可以用来进行与单词有关的位置匹配,字符串边界用来进行与字符串有关的位置匹配:一个用来匹配字符串开头的^,一个用来匹配字符串结尾的$。&lt;/p&gt;

&lt;p&gt;3) ^是有多种用途的元字符之一,只有当它出现在一个字符集合里(被放在[和]里,并紧跟在[的后边的时候,才能发挥求非的作用),如果用在一个字符集合的外边,并位于一个模式的开头,^将匹配字符串的开头。&lt;/p&gt;

&lt;p&gt;4) 要启用分行匹配模式,需要用(?m)元字符。在分行匹配模式下,^不仅能匹配一个正常的字符串开头,还将匹配换行分隔符后边的开始位置;$不仅能匹配正常的字符串结尾,还能匹配换行分隔符之后的结束位置。&lt;/p&gt;

&lt;h3 id=&quot;第7章-使用子表达式&quot;&gt;第7章 使用子表达式&lt;/h3&gt;

&lt;p&gt;讲述运用子表达式的概念对正则表达式进行分组和归类.&lt;/p&gt;

&lt;p&gt;1) 把一个表达式划分为一系列子表达式的目的是为了把那些子表达式当做一个独立元素来使用,子表达式必须用括号()括起来.&lt;/p&gt;

&lt;p&gt;2) 子表达式允许多重嵌套,嵌套层次在理论上没有限制,但是实际工作中还是要遵循适可而止的原则.&lt;/p&gt;

&lt;p&gt;3) 把必须匹配的情况考虑周全并写出一个匹配结果符合预期的正则表达式很容易,但把不需要匹配的情况也考虑周全并确保它们都被排除在外往往困难得多.&lt;/p&gt;

&lt;p&gt;4) 在面对子表达式嵌套很多的表达式的时候,应该按照先内后外的原则来进行而不是从第一个字符就开始一个字符一个字符地去处理.&lt;/p&gt;

&lt;p&gt;5) 子表达式的常见用途: 对重复次数元字符的作用对象做出精确的设定和控制,对|操作符的OR条件做出准确的定义等.&lt;/p&gt;

&lt;h3 id=&quot;第8章-回溯引用前后一直匹配&quot;&gt;第8章 回溯引用：前后一直匹配&lt;/h3&gt;

&lt;p&gt;讲述定义回溯应用&lt;/p&gt;

&lt;p&gt;1) 回溯引用允许正则表达式引用前面的匹配结果,回溯引用只能用来引用模式里的子表达式.&lt;/p&gt;

&lt;p&gt;2) 一些比较新的正则表达式还支持”命名捕获”,给某个子表达式起一个唯一的名字,并用名字引用子表达式(如Python),但是还没有得到广泛的支持,java好像并没有支持.&lt;/p&gt;

&lt;p&gt;3) 回溯引用可以跨模式使用,在第一个模式里被匹配的表达式可以用在第二个模式里.&lt;/p&gt;

&lt;h3 id=&quot;第9章-前后查找&quot;&gt;第9章 前后查找&lt;/h3&gt;

&lt;p&gt;讲述前后查找&lt;/p&gt;

&lt;p&gt;1) 当不需要匹配中的结果返回,只用来确定具体的位置的时候,需要前后查找.&lt;/p&gt;

&lt;p&gt;2) 向前查找制定了一个必须匹配但是不在结果中返回的模式,在向前查找里,被匹配到的文本不包含在最终返回的匹配结果里,被称为”不消费”.&lt;/p&gt;

&lt;p&gt;3) ?=被称为向前查找操作符,查找出现在匹配文本之前的字符,向后查找操作符是?&amp;lt;=.&lt;/p&gt;

&lt;p&gt;4) 向前查找模式的长度是可变的,可以包含.和+之类的元字符,所以非常灵活,向后查找模式只能是固定长度.&lt;/p&gt;

&lt;p&gt;5) 负向前查找要用(?!)来定义,负向后查找是(?&amp;lt;!)&lt;/p&gt;

&lt;h3 id=&quot;第10章-嵌入条件&quot;&gt;第10章 嵌入条件&lt;/h3&gt;

&lt;p&gt;讲述在正则表达式的内部嵌入条件处理功能&lt;/p&gt;

&lt;p&gt;1) 正则表达式里的几种条件:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;① ?匹配前一个字符或表达式,如果存在的话;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;② ?=和?&amp;lt;=匹配前面或后边的文本,如果存在.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2) 如下正则表达式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(\()?\d{3}(?(1)\)|-)\d{3}-\d{4}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个正则表达式提供了一个电话号码的解决方案,(()?匹配一个可选的左括号,用括号括起来得到了一个子表达式,随后的\d{3}匹配以为数字的区号,&lt;code class=&quot;highlighter-rouge&quot;&gt;(?(1)\)|-)&lt;/code&gt;是一个回溯引用条件,它根据条件是否得到满足而去匹配)或-;如果(1)存在,&lt;code class=&quot;highlighter-rouge&quot;&gt;\)&lt;/code&gt;必须被匹配,否则,-必须被匹配.&lt;/p&gt;

&lt;h3 id=&quot;附录元字符&quot;&gt;附录:元字符&lt;/h3&gt;

&lt;!-- &lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;元字符&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt; \d &lt;/td&gt; &lt;td&gt; 任何一个数字字符（等价于[0-9]）  &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td &gt;\D &lt;/td&gt; &lt;td&gt; 任何一个非数字字符(等价于[^0-9]) &lt;/td&gt;
  &lt;tr&gt;
    &lt;td&gt;\w &lt;/td&gt; &lt;td&gt; 任何一个字母数字字符或下划线字符（等价于[a-zA-Z0-9_]） &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;\W &lt;/td&gt; &lt;td&gt; 任何一个非字母数字字符或下划线字符（等价于[^a-zA-Z0-9_]） &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;\s &lt;/td&gt; &lt;td&gt; 任何一个空白字符（等价于[\f\n\r\t\v]） &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;\s &lt;/td&gt; &lt;td&gt; 任何一个非空白字符（等价于[^\f\n\r\t\v]） &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;\f &lt;/td&gt; &lt;td&gt; 换页符 &lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;\n &lt;/td&gt;&lt;td&gt;换行符 &lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;\t &lt;/td&gt;&lt;td&gt; 制表符 &lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;\v &lt;/td&gt; &lt;td&gt; 垂直制表符 &lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;\x &lt;/td&gt;&lt;td&gt; 匹配十六进制数字 &lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;\0 &lt;/td&gt;&lt;td&gt; 匹配八进制数字 &lt;/td&gt;&lt;/tr&gt;

&lt;/table&gt; --&gt;

&lt;h4 id=&quot;返回主目录&quot;&gt;&lt;a href=&quot;https://github.com/msg901216/get-rid-of-my-books/blob/master/README.md&quot;&gt;返回主目录&lt;/a&gt;&lt;/h4&gt;
</description>
        <pubDate>Sat, 07 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/07/Teach-Yourself-Regular-Expressions-in-10-Minutes/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/07/Teach-Yourself-Regular-Expressions-in-10-Minutes/</guid>
        
        <category>regex</category>
        
        <category>正则</category>
        
        <category>NLP</category>
        
        
      </item>
    
      <item>
        <title>Welcome to Hux Blog</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Yeah It’s on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;Hux 的 Blog 就这么开通了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#build&quot;&gt;跳过废话，直接看技术实现 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2015 年，Hux 总算有个地方可以好好写点东西了。&lt;/p&gt;

&lt;p&gt;作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。&lt;/p&gt;

&lt;p&gt;在玩了一段时间知乎之后，答题的快感又激起了我开博客的冲动。之前的&lt;a href=&quot;http://huangxuan.me/portfolio&quot;&gt;个人网站&lt;/a&gt;是作品集形式的（现在集成进来了），并不适合用来写博文，一不做二不休，花一天搞一个吧！&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;接下来说说搭建这个博客的技术细节。&lt;/p&gt;

&lt;p&gt;正好之前就有关注过 &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; + &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; 快速 Building Blog 的技术方案，非常轻松时尚。&lt;/p&gt;

&lt;p&gt;其优点非常明显：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Markdown&lt;/strong&gt; 带来的优雅写作体验&lt;/li&gt;
  &lt;li&gt;非常熟悉的 Git workflow ，&lt;strong&gt;Git Commit 即 Blog Post&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机
    &lt;ul&gt;
      &lt;li&gt;如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Jekyll 的自定制非常容易，基本就是个模版引擎&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个&lt;a href=&quot;http://huxpro.gitcafe.io&quot;&gt;镜像&lt;/a&gt;出来，结果还是巨慢。&lt;/p&gt;

&lt;p&gt;哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 &lt;strong&gt;pending 在了 Google Fonts&lt;/strong&gt; 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。&lt;br /&gt;
忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了，而且 GitHub 和 GitCafe 对比并没有感受到明显的速度差异，虽然 github 的 ping 值明显要高一些，达到了 300ms，于是用 DNSPOD 优化了一下速度。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手&lt;/p&gt;

&lt;p&gt;大的 Jekyll 主题上直接 fork 了 Clean Blog（这个主题也相当有名，就不多赘述了。唯一的缺点大概就是没有标签支持，于是我给它补上了。）&lt;/p&gt;

&lt;p&gt;本地调试环境需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;gem install jekyll&lt;/code&gt;，结果 rubygem 的源居然被墙了……后来手动改成了我大淘宝的镜像源才成功&lt;/p&gt;

&lt;p&gt;Theme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了（平时更习惯 SCSS 些），&lt;strong&gt;不过其实我一直觉得 Bootstrap 在移动端的体验做得相当一般，比我在淘宝参与的团队 CSS 框架差多了……&lt;/strong&gt;所以为了体验，也补了不少 CSS 进去&lt;/p&gt;

&lt;p&gt;最后就进入了耗时反而最长的&lt;strong&gt;做图、写字&lt;/strong&gt;阶段，也算是进入了&lt;strong&gt;写博客&lt;/strong&gt;的正轨，因为是类似 Hack Day 的方式去搭这个站的，所以折腾折腾着大半夜就过去了。&lt;/p&gt;

&lt;p&gt;第二天考虑中文字体的渲染，fork 了 &lt;a href=&quot;http://www.typeisbeautiful.com/&quot;&gt;Type is Beautiful&lt;/a&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;font&lt;/code&gt; CSS，调整了字号，适配了 Win 的渣渲染，中英文混排效果好多了。&lt;/p&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;回顾这个博客的诞生，纯粹是出于个人兴趣。在知乎相关问题上回答并获得一定的 star 后，我决定把这个博客主题当作一个小小的开源项目来维护。&lt;/p&gt;

&lt;p&gt;在经历 v1.0 - v1.5 的蜕变后，这个博客主题愈发完整，不但增加了诸多 UI 层的优化（opinionated）；在代码层面，更加丰富的配置项也使得这个主题拥有了更好的灵活性与可拓展性。而作为一个开源项目，我也积极的为其完善文档与解决 issue。&lt;/p&gt;

&lt;p&gt;如果你恰好逛到了这里，希望你也能喜欢这个博客主题。&lt;/p&gt;

&lt;p&gt;—— Hux 后记于 2015.10&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/01/29/hello-2015/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/01/29/hello-2015/</guid>
        
        <category>生活</category>
        
        
      </item>
    
  </channel>
</rss>
