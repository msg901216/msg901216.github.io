<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keywords"  content="">
    <meta name="theme-color" content="">
    
    <title>Git and github notes - 学习笔记 | Reading Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/2018/12/07/git-and-github/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script type="text/javascript" async
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async>
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
            inlineMath:  [ ["$", "$"] ],
            displayMath: [ ["$$","$$"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a'],
            ignoreClass:"comment-content"
        },
        "HTML-CSS": {
            availableFonts: ["STIX","TeX"],
            showMathMenu: false
        }
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    </script>
    
    <script data-no-instant>
    InstantClick.on('change', function(isInitialLoad){
        if (isInitialLoad === false) {
            if (typeof MathJax !== 'undefined'){
                MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
            }
        }
    });
    InstantClick.init();
    </script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">慢时光的学习笔记</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/posts/02.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/posts/02.jpg')
    }

    
    header.intro-header .header-mask{
        width: 100%;
        height: 100%;
        position: absolute;
        background: rgba(0,0,0, 0.3);
    }
    
</style>
<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#git" title="git">git</a>
                        
                        <a class="tag" href="/tags/#github" title="github">github</a>
                        
                        <a class="tag" href="/tags/#学习" title="学习">学习</a>
                        
                        <a class="tag" href="/tags/#转载" title="转载">转载</a>
                        
                    </div>
                    <h1>Git and github notes</h1>
                    
                    
                    <h2 class="subheading">git notes</h2>
                    
                    <span class="meta">Posted by msg on December 7, 2018</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<blockquote>
  <p>学习自<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰Git教程</a>、<a href="https://git-scm.com/doc">git官网</a></p>
</blockquote>

<h3 id="1在linux上安装gitubuntu为例">1、在Linux上安装Git(ubuntu为例)</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>git
</code></pre></div></div>

<p>但是这样下载的可能是比较老的版本，如果需要下载更新最新版本的git，需要如下操作：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>add-apt-repository ppa:git-core/ppa
<span class="nv">$ </span><span class="nb">sudo </span>apt-get update
<span class="nv">$ </span><span class="nb">sudo </span>apt-get upgrade
</code></pre></div></div>

<h3 id="2创建版本库">2、创建版本库</h3>

<p>首先，选择一个合适的地方，创建一个空目录：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir </span>learngit
<span class="nv">$ </span><span class="nb">cd </span>learngit
<span class="nv">$ </span><span class="nb">pwd</span>
/home/msg/learngit
</code></pre></div></div>

<p>第二步，通过<code class="highlighter-rouge">git init</code>命令把这个目录变成Git可以管理的仓库：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git init
Initialized empty Git repository in /home/msg/learngit/.git/
</code></pre></div></div>

<h3 id="3把文件添加到版本库">3、把文件添加到版本库</h3>

<p>第一步，用命令<code class="highlighter-rouge">git add</code>告诉Git，把文件添加到仓库：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git add readme.txt
</code></pre></div></div>

<p>第二步，用命令<code class="highlighter-rouge">git commit</code>告诉Git，把文件提交到仓库：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git commit <span class="nt">-m</span> <span class="s2">"wrote a readme file"</span>
</code></pre></div></div>

<h3 id="4修改文件">4、修改文件</h3>

<p>修改<code class="highlighter-rouge">readme.txt</code>文件之后，用<code class="highlighter-rouge">git diff</code>命令看看修改的内容：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git diff readme.txt 
</code></pre></div></div>

<p>再次用<code class="highlighter-rouge">git commit</code>提交：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git commit <span class="nt">-m</span> <span class="s2">"add distributed"</span>
</code></pre></div></div>

<h4 id="5版本回退">5、版本回退</h4>

<p>在Git中，我们用<code class="highlighter-rouge">git log</code>命令查看：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git log
</code></pre></div></div>

<p><code class="highlighter-rouge">git log</code>命令显示从最近到最远的提交日志</p>

<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code class="highlighter-rouge">--pretty=oneline</code>参数：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git log <span class="nt">--pretty</span><span class="o">=</span>oneline
</code></pre></div></div>

<p>要把当前版本回退到上一个版本<code class="highlighter-rouge">add distributed</code>，就可以使用<code class="highlighter-rouge">git reset</code>命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git reset <span class="nt">--hard</span> HEAD^
</code></pre></div></div>

<p>最新的版本已经看不到了，想再回去，只要上面的命令行窗口还没有被关掉，就可以找到那个版本的<code class="highlighter-rouge">commit id</code>是<code class="highlighter-rouge">1094adb...</code>，于是就可以指定回到未来的某个版本：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git reset <span class="nt">--hard</span> 1094a
HEAD is now at 83b0afe append GPL
</code></pre></div></div>

<p>当用<code class="highlighter-rouge">$ git reset --hard HEAD^</code>回退到上一版本并关闭了<code class="highlighter-rouge">terminal</code>时，再想恢复，就必须找到<code class="highlighter-rouge">commit id</code>。Git提供了一个命令<code class="highlighter-rouge">git reflog</code>用来记录你的每一次命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git reflog
e475afc HEAD@<span class="o">{</span>1<span class="o">}</span>: reset: moving to HEAD^
1094adb <span class="o">(</span>HEAD -&gt; master<span class="o">)</span> HEAD@<span class="o">{</span>2<span class="o">}</span>: commit: append GPL
</code></pre></div></div>

<p>可知，<code class="highlighter-rouge">上一个版本</code>的commit id是<code class="highlighter-rouge">1094adb</code>。</p>

<h3 id="6工作区和暂存区">6、工作区和暂存区</h3>

<h4 id="工作区working-directory">工作区（Working Directory）</h4>

<p>就是电脑里能看到的目录，比如<code class="highlighter-rouge">learngit</code>文件夹</p>

<h4 id="版本库repository">版本库（Repository）</h4>

<p>工作区有一个隐藏目录<code class="highlighter-rouge">.git</code>，这个不算工作区，而是Git的版本库。</p>

<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code class="highlighter-rouge">master</code>，以及指向<code class="highlighter-rouge">master</code>的一个指针叫<code class="highlighter-rouge">HEAD</code>。</p>

<p>创建Git版本库时，Git自动为我们创建了唯一一个<code class="highlighter-rouge">master</code>分支，所以，现在，<code class="highlighter-rouge">git commit</code>就是往<code class="highlighter-rouge">master</code>分支上提交更改。</p>

<h3 id="7撤销修改">7、撤销修改</h3>

<p><code class="highlighter-rouge">git checkout -- file</code>可以丢弃工作区的修改：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout -- readme.txt
</code></pre></div></div>

<p>命令<code class="highlighter-rouge">git checkout -- readme.txt</code>意思就是，把<code class="highlighter-rouge">readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">readme.txt</code>自修改后还没有被放到暂存区，撤销修改就回到和版本库一模一样的状态；</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">readme.txt</code>已经添加到暂存区后，又作了修改，撤销修改就回到添加到暂存区后的状态。</p>
  </li>
</ul>

<p>总之，就是让这个文件回到最近一次<code class="highlighter-rouge">git commit</code>或<code class="highlighter-rouge">git add</code>时的状态。</p>

<p>命令<code class="highlighter-rouge">git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git reset HEAD readme.txt
</code></pre></div></div>

<h3 id="8删除文件">8、删除文件</h3>

<p>直接在文件管理器中把没用的文件删了，或者用<code class="highlighter-rouge">rm</code>命令删了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rm test.txt
</code></pre></div></div>

<p>Git知道你删除了文件，工作区和版本库就不一致了，<code class="highlighter-rouge">git status</code>命令会立刻告诉你哪些文件被删除了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git status
</code></pre></div></div>

<p>用命令<code class="highlighter-rouge">git rm</code>删掉，并且<code class="highlighter-rouge">git commit</code>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git rm test.txt
$ git commit -m "remove test.txt"
</code></pre></div></div>

<p>删错了，版本库里还有，可以很轻松地把误删的文件恢复到最新版本：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout -- test.txt
</code></pre></div></div>

<p><code class="highlighter-rouge">git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>

<h3 id="9添加远程库">9、添加远程库</h3>

<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库</p>

<p>在Repository name填入<code class="highlighter-rouge">learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p>

<p>根据GitHub的提示，在本地的<code class="highlighter-rouge">learngit</code>仓库下运行命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git remote add origin git@github.com:XXX/learngit.git
</code></pre></div></div>

<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git push <span class="nt">-u</span> origin master
</code></pre></div></div>

<p>把本地库的内容推送到远程，用<code class="highlighter-rouge">git push</code>命令，实际上是把当前分支<code class="highlighter-rouge">master</code>推送到远程。</p>

<p>由于远程库是空的，第一次推送<code class="highlighter-rouge">master</code>分支时，加上了<code class="highlighter-rouge">-u</code>参数，Git不但会把本地的<code class="highlighter-rouge">master</code>分支内容推送到远程新的<code class="highlighter-rouge">master</code>分支，还会把本地的<code class="highlighter-rouge">master</code>分支和远程的<code class="highlighter-rouge">master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>

<p>从现在起，只要本地作了提交，就可以通过命令：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git push origin master
</code></pre></div></div>

<h4 id="ssh警告">SSH警告</h4>

<p>当你第一次使用Git的<code class="highlighter-rouge">clone</code>或者<code class="highlighter-rouge">push</code>命令连接GitHub时，会得到一个警告：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.
RSA key fingerprint is xx.xx.xx.xx.xx.
Are you sure you want to continue connecting (yes/no)?
</code></pre></div></div>

<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code class="highlighter-rouge">yes</code>回车即可。</p>

<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Warning: Permanently added 'github.com' (RSA) to the list of known hosts.
</code></pre></div></div>

<p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>

<h3 id="10从远程库克隆">10、从远程库克隆</h3>

<p>用命令<code class="highlighter-rouge">git clone</code>克隆一个本地库：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git clone git@github.com:XXX/gitskills.git
</code></pre></div></div>

<p><code class="highlighter-rouge">https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code class="highlighter-rouge">ssh</code>协议而只能用<code class="highlighter-rouge">https</code>。</p>

<h3 id="11创建与合并分支">11、创建与合并分支</h3>

<p>Git把每次提交串成一条时间线，这条时间线就是一个分支。一开始只有一条时间线，在Git里，这个分支叫主分支，即<code class="highlighter-rouge">master</code>分支。<code class="highlighter-rouge">HEAD</code>严格来说不是指向提交，而是指向<code class="highlighter-rouge">master</code>，<code class="highlighter-rouge">master</code>才是指向提交的，所以，<code class="highlighter-rouge">HEAD</code>指向的就是当前分支。</p>

<p>一开始的时候，<code class="highlighter-rouge">master</code>分支是一条线，Git用<code class="highlighter-rouge">master</code>指向最新的提交，再用<code class="highlighter-rouge">HEAD</code>指向<code class="highlighter-rouge">master</code>，就能确定当前分支，以及当前分支的提交点。</p>

<p>如果创建新的分支，例如<code class="highlighter-rouge">dev</code>，Git新建了一个指针叫<code class="highlighter-rouge">dev</code>，指向<code class="highlighter-rouge">master</code>相同的提交，再把<code class="highlighter-rouge">HEAD</code>指向<code class="highlighter-rouge">dev</code>，就表示当前分支在<code class="highlighter-rouge">dev</code>上：</p>

<p>从现在开始，对工作区的修改和提交就是针对<code class="highlighter-rouge">dev</code>分支了，比如新提交一次后，<code class="highlighter-rouge">dev</code>指针往前移动一步，而<code class="highlighter-rouge">master</code>指针不变。</p>

<p>假如我们在<code class="highlighter-rouge">dev</code>上的工作完成了，就可以把<code class="highlighter-rouge">dev</code>合并到<code class="highlighter-rouge">master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code class="highlighter-rouge">master</code>指向<code class="highlighter-rouge">dev</code>的当前提交，就完成了合并。</p>

<p>合并完分支后，甚至可以删除<code class="highlighter-rouge">dev</code>分支。删除<code class="highlighter-rouge">dev</code>分支就是把<code class="highlighter-rouge">dev</code>指针给删掉，删掉后，我们就剩下了一条<code class="highlighter-rouge">master</code>分支。</p>

<h4 id="实战">实战</h4>

<p>首先创建<code class="highlighter-rouge">dev</code>分支，然后切换到<code class="highlighter-rouge">dev</code>分支：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout -b dev
</code></pre></div></div>

<p><code class="highlighter-rouge">git checkout</code>命令加上<code class="highlighter-rouge">-b</code>参数表示创建并切换，相当于以下两条命令：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch dev
$ git checkout dev
</code></pre></div></div>

<p>然后，用<code class="highlighter-rouge">git branch</code>命令查看当前分支：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch
</code></pre></div></div>

<p><code class="highlighter-rouge">git branch</code>命令会列出所有分支，当前分支前面会标一个<code class="highlighter-rouge">*</code>号。</p>

<p>然后，可以在<code class="highlighter-rouge">dev</code>分支上正常提交，比如对readme.txt做个修改，加上一行：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Creating a new branch is quick.
</code></pre></div></div>

<p>然后提交：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add readme.txt 
$ git commit -m "branch test"
</code></pre></div></div>

<p>现在，<code class="highlighter-rouge">dev</code>分支的工作完成，我们就可以切换回<code class="highlighter-rouge">master</code>分支：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout master
</code></pre></div></div>

<p>现在，我们把<code class="highlighter-rouge">dev</code>分支的工作成果合并到<code class="highlighter-rouge">master</code>分支上：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git merge dev
Updating d46f35e..b17d20e
Fast-forward
 readme.txt | 1 +
 1 file changed, 1 insertion(+)
</code></pre></div></div>

<p><code class="highlighter-rouge">git merge</code>命令用于合并指定分支到当前分支。</p>

<p><code class="highlighter-rouge">Fast-forward</code>就是直接把<code class="highlighter-rouge">master</code>指向<code class="highlighter-rouge">dev</code>的当前提交，所以合并速度非常快。</p>

<p>合并完成后，就可以放心地删除<code class="highlighter-rouge">dev</code>分支了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch -d dev
</code></pre></div></div>

<p>删除后，查看<code class="highlighter-rouge">branch</code>，就只剩下<code class="highlighter-rouge">master</code>分支了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch
</code></pre></div></div>

<p>删除远程分支</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push origin <span class="nt">--delete</span> dev
</code></pre></div></div>

<h3 id="12解决冲突">12、解决冲突</h3>

<p>准备新的<code class="highlighter-rouge">feature1</code>分支，继续新分支开发：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout -b feature1
</code></pre></div></div>

<p>修改<code class="highlighter-rouge">readme.txt</code>最后一行，改为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Creating a new branch is quick AND simple.
</code></pre></div></div>

<p>在<code class="highlighter-rouge">feature1</code>分支上提交：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add readme.txt
$ git commit -m "AND simple"
</code></pre></div></div>

<p>切换到<code class="highlighter-rouge">master</code>分支：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout master
</code></pre></div></div>

<p>Git还会自动提示我们当前<code class="highlighter-rouge">master</code>分支比远程的<code class="highlighter-rouge">master</code>分支要超前1个提交。</p>

<p>在<code class="highlighter-rouge">master</code>分支上把<code class="highlighter-rouge">readme.txt</code>文件的最后一行改为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Creating a new branch is quick &amp; simple.
</code></pre></div></div>

<p>提交：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add readme.txt 
$ git commit -m "&amp; simple"
</code></pre></div></div>

<p>现在，<code class="highlighter-rouge">master</code>分支和<code class="highlighter-rouge">feature1</code>分支各自都分别有新的提交。</p>

<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git merge feature1
</code></pre></div></div>

<p><code class="highlighter-rouge">readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git status
</code></pre></div></div>

<p>直接查看readme.txt的内容：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1
</code></pre></div></div>

<p>Git用<code class="highlighter-rouge">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code class="highlighter-rouge">=======</code>，<code class="highlighter-rouge">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Creating a new branch is quick and simple.
</code></pre></div></div>

<p>再提交：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add readme.txt 
$ git commit -m "conflict fixed"
</code></pre></div></div>

<p>用带参数的<code class="highlighter-rouge">git log</code>也可以看到分支的合并情况：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git log --graph --pretty=oneline --abbrev-commit
</code></pre></div></div>

<p>最后，删除<code class="highlighter-rouge">feature1</code>分支：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch -d feature1
</code></pre></div></div>

<p>工作完成。</p>

<h3 id="13分支管理策略">13、分支管理策略</h3>

<p>通常，合并分支时，如果可能，Git会用<code class="highlighter-rouge">Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>

<p>如果要强制禁用<code class="highlighter-rouge">Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>

<p>下面我们实战一下<code class="highlighter-rouge">--no-ff</code>方式的<code class="highlighter-rouge">git merge</code>：</p>

<p>首先，仍然创建并切换<code class="highlighter-rouge">dev</code>分支：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout -b dev
Switched to a new branch 'dev'
</code></pre></div></div>

<p>修改readme.txt文件，并提交一个新的commit：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add readme.txt 
$ git commit -m "add merge"
</code></pre></div></div>

<p>切换回<code class="highlighter-rouge">master</code>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout master
</code></pre></div></div>

<p>准备合并<code class="highlighter-rouge">dev</code>分支，请注意<code class="highlighter-rouge">--no-ff</code>参数，表示禁用<code class="highlighter-rouge">Fast forward</code>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git merge --no-ff -m "merge with no-ff" dev
</code></pre></div></div>

<p>本次合并要创建一个新的commit，所以加上<code class="highlighter-rouge">-m</code>参数，把commit描述写进去。</p>

<p>合并后，我们用<code class="highlighter-rouge">git log</code>看看分支历史：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git log --graph --pretty=oneline --abbrev-commit
</code></pre></div></div>

<h3 id="14bug分支">14、Bug分支</h3>

<p>Git还提供了一个<code class="highlighter-rouge">stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git stash
Saved working directory and index state WIP on dev: f52c633 add merge
</code></pre></div></div>

<p>现在，用<code class="highlighter-rouge">git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>

<p>首先确定要在哪个分支上修复bug，假定需要在<code class="highlighter-rouge">master</code>分支上修复，就从<code class="highlighter-rouge">master</code>创建临时分支：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout master
$ git checkout -b issue-101
</code></pre></div></div>

<p>现在修复bug，然后提交。</p>

<p>修复完成后，切换到<code class="highlighter-rouge">master</code>分支，并完成合并，最后删除<code class="highlighter-rouge">issue-101</code>分支：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout master
$ git merge --no-ff -m "merged bug fix 101" issue-101
</code></pre></div></div>

<p>接着回到<code class="highlighter-rouge">dev</code>分支:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout dev
$ git status
</code></pre></div></div>

<p>工作区是干净的，刚才的工作现场存到哪去了？用<code class="highlighter-rouge">git stash list</code>命令看看：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git stash list
stash@{0}: WIP on dev: f52c633 add merge
</code></pre></div></div>

<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>

<p>一是用<code class="highlighter-rouge">git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code class="highlighter-rouge">git stash drop</code>来删除；</p>

<p>另一种方式是用<code class="highlighter-rouge">git stash pop</code>，恢复的同时把stash内容也删了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git stash pop
</code></pre></div></div>

<p>再用<code class="highlighter-rouge">git stash list</code>查看，就看不到任何stash内容了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git stash list
</code></pre></div></div>

<p>你可以多次stash，恢复的时候，先用<code class="highlighter-rouge">git stash list</code>查看，然后恢复指定的stash，用命令：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git stash apply stash@{0}
</code></pre></div></div>

<h3 id="15feature分支">15、Feature分支</h3>

<p>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout <span class="nt">-b</span> feature-vulcan
Switched to a new branch <span class="s1">'feature-vulcan'</span>
</code></pre></div></div>

<p>5分钟后，开发完毕：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add vulcan.py
$ git status
$ git commit -m "add feature vulcan"
</code></pre></div></div>

<p>切回<code class="highlighter-rouge">dev</code>，准备合并：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout dev
</code></pre></div></div>

<p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p>

<p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch -d feature-vulcan
</code></pre></div></div>

<p>销毁失败。Git友情提醒，<code class="highlighter-rouge">feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code class="highlighter-rouge">-D</code>参数。。</p>

<p>现在我们强行删除：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch -D feature-vulcan
Deleted branch feature-vulcan (was 287773e).
</code></pre></div></div>

<p>终于删除成功！</p>

<h3 id="16多人协作">16、多人协作</h3>

<p>当从远程仓库克隆时，实际上Git自动把本地的<code class="highlighter-rouge">master</code>分支和远程的<code class="highlighter-rouge">master</code>分支对应起来了，并且，远程仓库的默认名称是<code class="highlighter-rouge">origin</code>。</p>

<p>要查看远程库的信息，用<code class="highlighter-rouge">git remote</code>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git remote
origin
</code></pre></div></div>

<p>或者，用<code class="highlighter-rouge">git remote -v</code>显示更详细的信息：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git remote -v
origin  git@github.com:michaelliao/learngit.git (fetch)
origin  git@github.com:michaelliao/learngit.git (push)
</code></pre></div></div>

<p>上面显示了可以抓取和推送的<code class="highlighter-rouge">origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>

<h4 id="推送分支">推送分支</h4>

<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git push origin master
</code></pre></div></div>

<p>如果要推送其他分支，比如<code class="highlighter-rouge">dev</code>，就改成：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git push origin dev
</code></pre></div></div>

<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>

<ul>
  <li><code class="highlighter-rouge">master</code>分支是主分支，因此要时刻与远程同步；</li>
  <li><code class="highlighter-rouge">dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
  <li><code class="highlighter-rouge">bug</code>分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
  <li><code class="highlighter-rouge">feature</code>分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>

<h4 id="抓取分支">抓取分支</h4>

<p>多人协作时，大家都会往<code class="highlighter-rouge">master</code>和<code class="highlighter-rouge">dev</code>分支上推送各自的修改。</p>

<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git clone git@github.com:XXX/learngit.git
</code></pre></div></div>

<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code class="highlighter-rouge">master</code>分支。不信可以用<code class="highlighter-rouge">git branch</code>命令看看：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch
* master
</code></pre></div></div>

<p>现在，你的小伙伴要在<code class="highlighter-rouge">dev</code>分支上开发，就必须创建远程<code class="highlighter-rouge">origin</code>的<code class="highlighter-rouge">dev</code>分支到本地，于是他用这个命令创建本地<code class="highlighter-rouge">dev</code>分支：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout -b dev origin/dev
</code></pre></div></div>

<p>现在，他就可以在<code class="highlighter-rouge">dev</code>上继续修改，然后，时不时地把<code class="highlighter-rouge">dev</code>分支<code class="highlighter-rouge">push</code>到远程：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add env.txt
$ git commit -m "add env"
$ git push origin dev
</code></pre></div></div>

<p>你的小伙伴已经向<code class="highlighter-rouge">origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat env.txt
$ git add env.txt
$ git commit -m "add new env"
$ git push origin dev
</code></pre></div></div>

<p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code class="highlighter-rouge">git pull</code>把最新的提交从<code class="highlighter-rouge">origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git pull
</code></pre></div></div>

<p><code class="highlighter-rouge">git pull</code>也失败了，原因是没有指定本地<code class="highlighter-rouge">dev</code>分支与远程<code class="highlighter-rouge">origin/dev</code>分支的链接，根据提示，设置<code class="highlighter-rouge">dev</code>和<code class="highlighter-rouge">origin/dev</code>的链接：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch --set-upstream-to=origin/dev dev
Branch 'dev' set up to track remote branch 'dev' from 'origin'.
</code></pre></div></div>

<p>再pull：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git pull
</code></pre></div></div>

<p>这回<code class="highlighter-rouge">git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000">解决冲突</a>完全一样。解决后，提交，再push：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git commit -m "fix env conflict"
$ git push origin dev
</code></pre></div></div>

<p>因此，多人协作的工作模式通常是这样：</p>

<ol>
  <li>首先，可以试图用<code class="highlighter-rouge">git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
  <li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code class="highlighter-rouge">git pull</code>试图合并；</li>
  <li>如果合并有冲突，则解决冲突，并在本地提交；</li>
  <li>没有冲突或者解决掉冲突后，再用<code class="highlighter-rouge">git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>

<p>如果<code class="highlighter-rouge">git pull</code>提示<code class="highlighter-rouge">no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code class="highlighter-rouge">git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>

<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>

<h3 id="17rebase">17、Rebase</h3>

<p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p>

<p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git rebase
<span class="nv">$ </span>git log
</code></pre></div></div>

<h3 id="18创建标签">18、创建标签</h3>

<p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch
* dev
  master
$ git checkout master
Switched to branch 'master'
</code></pre></div></div>

<p>然后，敲命令<code class="highlighter-rouge">git tag &lt;name&gt;</code>就可以打一个新标签：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git tag v1.0
</code></pre></div></div>

<p>可以用命令<code class="highlighter-rouge">git tag</code>查看所有标签：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git tag
v1.0
</code></pre></div></div>

<p>忘了打标签，找到历史提交的commit id，然后打上就可以了：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git log <span class="nt">--pretty</span><span class="o">=</span>oneline <span class="nt">--abbrev-commit</span>
12a631b <span class="o">(</span>HEAD -&gt; master, tag: v1.0, origin/master<span class="o">)</span> merged bug fix 101
4c805e2 fix bug 101
e1e9c68 merge with no-ff
f52c633 add merge
...
</code></pre></div></div>

<p>比方说要对<code class="highlighter-rouge">add merge</code>这次提交打标签，它对应的commit id是<code class="highlighter-rouge">f52c633</code>，敲入命令：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git tag v0.9 f52c633
</code></pre></div></div>

<p>再用命令<code class="highlighter-rouge">git tag</code>查看标签：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git tag
v0.9
v1.0
</code></pre></div></div>

<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code class="highlighter-rouge">git show &lt;tagname&gt;</code>查看标签信息：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git show v0.9
commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:56:54 2018 +0800

    add merge

diff --git a/readme.txt b/readme.txt
...
</code></pre></div></div>

<p>可以看到，<code class="highlighter-rouge">v0.9</code>确实打在<code class="highlighter-rouge">add merge</code>这次提交上。</p>

<p>还可以创建带有说明的标签，用<code class="highlighter-rouge">-a</code>指定标签名，<code class="highlighter-rouge">-m</code>指定说明文字：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git tag -a v0.1 -m "version 0.1 released" 1094adb
</code></pre></div></div>

<p>用命令<code class="highlighter-rouge">git show &lt;tagname&gt;</code>可以看到说明文字：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git show v0.1
tag v0.1
Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 22:48:43 2018 +0800
...
</code></pre></div></div>

<h3 id="19操作标签">19、操作标签</h3>

<p>如果标签打错了，也可以删除：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git tag -d v0.1
</code></pre></div></div>

<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>

<p>如果要推送某个标签到远程，使用命令<code class="highlighter-rouge">git push origin &lt;tagname&gt;</code>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git push origin v1.0
</code></pre></div></div>

<p>或者，一次性推送全部尚未推送到远程的本地标签：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git push origin --tags
</code></pre></div></div>

<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git tag -d v0.9
Deleted tag 'v0.9' (was f52c633)
</code></pre></div></div>

<p>然后，从远程删除。删除命令也是push，但是格式如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git push origin :refs/tags/v0.9
</code></pre></div></div>

<p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>

<h3 id="20github">20、github</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git remote -v
</code></pre></div></div>

<p>删除已有的GitHub远程库：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git remote rm origin
</code></pre></div></div>

<h3 id="21配置别名">21、配置别名</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git config <span class="nt">--global</span> alias.co checkout
<span class="nv">$ </span>git config <span class="nt">--global</span> alias.ci commit
<span class="nv">$ </span>git config <span class="nt">--global</span> alias.br branch
<span class="nv">$ </span>git config <span class="nt">--global</span> alias.st status
<span class="nv">$ </span>git config <span class="nt">--global</span> alias.lg <span class="s2">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span>
<span class="nv">$ </span>git config <span class="nt">--global</span> alias.last <span class="s1">'log -1'</span>
<span class="nv">$ </span>git config <span class="nt">--global</span> alias.unstage <span class="s1">'reset HEAD'</span>
</code></pre></div></div>

<h3 id="22删除过大的文件记录">22、删除过大的文件记录</h3>

<ul>
  <li>Step 1 查看哪些历史提交过文件占用空间较大</li>
</ul>

<p>使用以下命令可以查看占用空间最多的五个文件：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git rev-list --objects --all | grep "$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -5 | awk '{print$1}')"

</code></pre></div></div>
<p>rev-list命令用来列出Git仓库中的提交，我们用它来列出所有提交中涉及的文件名及其ID。 该命令可以指定只显示某个引用（或分支）的上下游的提交。</p>

<p>–objects：列出该提交涉及的所有文件ID。</p>

<p>–all：所有分支的提交，相当于指定了位于/refs下的所有引用。</p>

<p>verify-pack命令用于显示已打包的内容。</p>

<ul>
  <li>step 2. 重写commit，删除大文件</li>
</ul>

<p>使用以下命令，删除历史提交过的大文件：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git filter-branch --force --index-filter 'git rm -rf --cached --ignore-unmatch big-file.jar' --prune-empty --tag-name-filter cat -- --all
</code></pre></div></div>

<p>上面脚本中的big-file.jar请换成你第一步查出的大文件名，或者这里直接写一个目录。</p>

<p>filter-branch命令可以用来重写Git仓库中的提交</p>

<p>–index-filter参数用来指定一条Bash命令，然后Git会检出（checkout）所有的提交， 执行该命令，然后重新提交。</p>

<p>–all参数表示我们需要重写所有分支（或引用）。</p>

<p>在重写提交的过程中，会有以下日志输出:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Rewrite 6cdbb293d453ced07e6a07e0aa6e580e6a5538f4 (266/266)
# Ref 'refs/heads/master' was rewritten
</code></pre></div></div>

<p>如果显示 xxxxx unchanged, 说明repo里没有找到该文件, 请检查路径和文件名是否正确，重复上面的脚本，把所有你想删除的文件都删掉。</p>

<ul>
  <li>step 3. 推送修改后的repo</li>
</ul>

<p>以强制覆盖的方式推送你的repo, 命令如下:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push origin master --force
</code></pre></div></div>

<ul>
  <li>step 4. 清理和回收空间</li>
</ul>

<p>虽然上面我们已经删除了文件, 但是我们的repo里面仍然保留了这些objects, 等待垃圾回收(GC), 所以我们要用命令彻底清除它, 并收回空间，命令如下:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm -rf .git/refs/original/

git reflog expire --expire=now --all

git gc --prune=now
</code></pre></div></div>

<p>至此，我们已经彻底的删除了我们不想要的文件。</p>



                <hr style="visibility: hidden;">

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/12/05/2019%E8%AE%A1%E5%88%92/" data-toggle="tooltip" data-placement="top" title="2019计划">
                        Previous<br>
                        <span>2019计划</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/12/11/neo4j-notes/" data-toggle="tooltip" data-placement="top" title="neo4j学习笔记">
                        Next<br>
                        <span>neo4j学习笔记</span>
                        </a>
                    </li>
                    
                </ul>


                

                
            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#NLP" title="NLP" rel="9">
                                    NLP
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#数学" title="数学" rel="6">
                                    数学
                                </a>
                            
        				
                            
                				<a href="/tags/#自然语言处理" title="自然语言处理" rel="10">
                                    自然语言处理
                                </a>
                            
        				
                            
                				<a href="/tags/#励志" title="励志" rel="5">
                                    励志
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#转载" title="转载" rel="23">
                                    转载
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#学习" title="学习" rel="25">
                                    学习
                                </a>
                            
        				
                            
                				<a href="/tags/#java" title="java" rel="7">
                                    java
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#笔记" title="笔记" rel="3">
                                    笔记
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#ubuntu" title="ubuntu" rel="5">
                                    ubuntu
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>









<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    


                    
                    
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 慢时光的学习笔记 2019
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async('/js/jquery.tagcloud.js',function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
